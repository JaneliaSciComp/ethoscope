#@include 
NULL
#' Read data from aresult file.
#' 
#' This function is used to convert all the information
#' contained in a result file generated by PSV into R dataframe(s).
#'
#' @param FILE the name of the input file.
#' @param rois a vector of ROI indices to read. NULL returns all ROIs
#' @param min_time exclude data before min_time (in seconds)
#' @param max_time exclude data after max_time (in seconds)
#' @param relative_distance whether distance is converted between 0 and 1 relatively to the width of the ROI. If FALSE, varibales such as x,y, w and h are returned is returned in absolute number of pixels.
#' @param FUN an optionnal function to be applied to the resulting dataframe. It can be used, for instance, to compute summary statistics, or to transform the data.
#' @param ... extra arguments to be passed to \code{FUN}
#' @return If \code{rois} has only one element, a dataframe. Otherwise, a list of dataframes (one per ROI)
#' @note Analysis of many long (sevaral days) recording can use a lot of memory. 
#' Therefore, it can be advantageaous to load an process ROIs one by one.
#' @examples
#' \dontrun{
#' FILE <- "result.db"
#' out <- loadROIsFromFile(FILE,c(1,3,55))
#' #histogram of x marginal distribution
#' hist(out$ROI_1$x, nclass=100)
#' }
#' \dontrun{
#' ####### Using the FUN argument to resample data as it is loaded.
#' # This is preferable for very large dataset, or when owrking with
#' # little RAM.
#' # First, we compute the last time point available for all ROIs
#' out <- loadROIsFromFile(FILE, FUN=function(d)max(d$t))
#' max_t <- max(unlist(out))
#'
#' # Then we apply the interpolateROIData to all ROIs
#'  out <- loadROIsFromFile(FILE, 
#' 	FUN=interpolateROIData, start=0,
#' 	stop = max_t, fs=1)
#' 	}
#' @seealso \code{\link{loadMetaData}} To display global informations about the experiment. 
#' @export
loadROIsFromFile <- function(FILE, rois = NULL, min_time = 0, max_time = Inf, relative_distances = TRUE, FUN=NULL, ...){
	
	time_in_seconds <- TRUE
	
	con <- dbConnect(SQLite(), FILE)
	roi_map <- dbGetQuery(con, "SELECT * FROM ROI_MAP")
	var_map <- dbGetQuery(con, "SELECT * FROM VAR_MAP")
	
	rownames(roi_map) <- roi_map$roi_idx
	rownames(var_map) <- var_map$var_name
	
	available_rois  <- roi_map$roi_idx
	if(is.null(rois))
		rois <- available_rois
	
	matched <- rois %in% available_rois
	
	unmatched_idx <-  which(!matched)
	
	for(i in rois[unmatched_idx])
		warning(sprintf("Roi %i is not in the table", i))
	
	
	rois <- rois[matched]
	
	if (length(rois) == 0)
		stop(sprintf("No ROI to be read. available ROIs are: %s", str(sort(available_rois))))
	
	if(max_time == Inf)
		max_time_condition <- ""
	else
		max_time_condition <-  sprintf("AND t < %e", max_time * 1000) 
	
	min_time <- min_time * 1000 # to ms
	
	sql_query_fun <- function(i){
		sql_query <- sprintf("SELECT * FROM ROI_%i WHERE t >= %e %s",i,min_time, max_time_condition )
		roi_df <- dbGetQuery(con, sql_query)	
		roi_df$id <- NULL
		if(time_in_seconds)
			roi_df$t <- roi_df$t / 1e3
		roi_row <- subset(roi_map, roi_idx == i)
		
		w <- max(c(roi_row[1,"w"], roi_row[1,"h"]))
		for(var_n in var_map$var_name){
			
			if(var_map[var_n, "functional_type"] == "distance")
				roi_df[,var_n] <- roi_df[,var_n]/ w
			if(var_map[var_n, "sql_type"] == "BOOLEAN")
				roi_df[,var_n] <- as.logical(roi_df[,var_n])
			
		}
			
		if(!is.null(FUN))
			out_roi_data <- FUN(roi_df, ...)
			
		return(out_roi_data)
	}
	out <- lapply(rois, sql_query_fun)
	dbDisconnect(con)
	
	names(out) <- paste0("ROI_", rois)

	
	if(length(out) == 1)
		return (out[[1]])
		
	return(out)		
}


NULL
#' Get metadata from a result file.
#' 
#' This function is used to obtain meta data -- such as `time and date of the experiment' , `aquisition device', `version of the software' and others--
#' contained in a result file generated by PSV.
#'
#' @param FILE the name of the input file.
#' @return A list containing fields for metadata entries
#' @examples
#' \dontrun{
#' FILE <- "result.db"
#' out <- loadMetaData(FILE)
#' names(out)
#' }
#' @seealso \code{\link{loadROIsFromFile}} to obtain raw experiemental data. 
#' @export
loadMetaData <- function(FILE){
	con <- dbConnect(SQLite(), FILE)
	metadata <- dbGetQuery(con, "SELECT * FROM METADATA")
	dbDisconnect(con)
	v <- as.list(metadata$value)
	names(v) <- metadata$field
	#fixme explicitly GMT
	v$date_time <- as.POSIXct(as.integer(v$date_time),origin="1970-01-01")
	return(v)		
	}
	
#~ #' Get metadata from a result file.
#~ #' 
#~ #' This function is used to get general
#~ #' information about a CSV-like result file generated by UbiTrail.
#~ #' @param FILE the name of the file from which the metadata are to be read.
#~ #' @return A list of two elements. The first element contains a vector of strings corresponding to
#~ #' global information such as the width and height of the video and the date.
#~ #' The second element contains a matrix in which each column corresponds to an area, and four rows to
#~ #' describe its respective position and dimensions.
#~ #' @note The metadata is in the first line of the CSV file.  It is pre-formated as an R expression. Therefore, 
#~ #' if you want to analyse data with another toolkit than R, you need to write a short function to parse the metadata.
#~ #' @examples
#~ #' \dontrun{
#~ #' me <- ubitMetaData('Results.csv') 
#~ #' me
#~ #' }
#~ #' @seealso \code{\link{ubitData}} to get only data from a CSV-like result file as a matrix.
#~ #' @seealso \code{\link{ubitLoad}} to read a result file into a list of areas (more convenient).
#~ #' @export
#~ ubitMetaData <- function(FILE){
#~     e<-scan(FILE,what='character',nline=1)
#~     meta<-eval(parse(text=e))
#~     
#~     H <- as.numeric(meta$Global['Height']) 
#~     meta$Areas['Y',] <- (H - meta$Areas['Y',]) - meta$Areas['H',]
#~     return(meta)
#~ }
#~ 	
#~ NULL
#~ #' Get data from a result file.
#~ #' 
#~ #' This function is used to read data from
#~ #' a CSV-like result file generated by UbiTrail.
#~ #' @param FILE the name of the file which the data are to be read from.
#~ #' @return A numerical matrix.
#~ #' @note The returned matrix has a different variable in each column and each row is a `read'.
#~ #' A read is written by UbiTrail every time an agent is detected. Therefore, a read contains information
#~ #' about area, territory, position and time.
#~ #'  
#~ #' @examples
#~ #' \dontrun{
#~ #' da <- ubitData('Results.csv') 
#~ #' summary(da)
#~ #' }
#~ #' @seealso \code{\link{ubitMetaData}} to get only metadata from the first line of a CSV-like result file.
#~ #' @seealso \code{\link{ubitLoadFile}} to read a result file into a list of areas (more convenient).
#~ #' @export
#~ ubitData<- function(FILE){
#~     n<-scan(FILE,what='character',skip=1,sep=',',nlines=1)
#~     a<-scan(FILE,skip=2,sep=',')
#~     nc<-length(n)
#~     nr<-length(a)/nc
#~     m_<-matrix(a,nr,nc,byrow=T)
#~     colnames(m_) <- n
#~     m_[,'Y'] <- 1 - m_[,'Y']
#~     m_
#~ }
#~ NULL
#~ #' Parse data matrix to a list of matrices.
#~ #' 
#~ #' This function is used to combine metadata and data into a list of matrices.
#~ #' @param data a matrix of numerical data.
#~ #' @param meta a list of metadata.
#~ #' @return A list of numerical matrices.
#~ #' @note The returned list contains a numerical matrix for each area.
#~ #' The attributes of list contain metadata.
#~ #' Each matrix in the list is assigned attributes about the area it represents.
#~ #' 
#~ #' @examples
#~ #' \dontrun{
#~ #' da <- ubitData('Results.csv') 
#~ #' me <- ubitMetaData('Results.csv') 
#~ #' l <- ubitParseDataToList(da,me)
#~ #' attributes(l)
#~ #' }
#~ #' @seealso \code{\link{ubitMetaData}} to get only metadata from the first line of a CSV-like result file.
#~ #' @seealso \code{\link{ubitData}} to get only data from a CSV-like result file as a matrix.
#~ #' @seealso \code{\link{ubitLoadFile}} to read a result file into a list of areas (more convenient).
#~ #' @export
#~ ubitParseDataToList <- function(data,meta){
#~ 	Global <- meta$Global
#~ 	Areas <- meta$Areas
#~ 	l <- lapply(colnames(Areas),h_ubitSetAttributes,m=data,areas = Areas)
#~ 	names(l) <- colnames(meta$Areas)
#~     attributes(l) <- c(attributes(l),as.list(Global))
#~     l
#~ 	}
#~ 
